<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
<head>
<title>3.19.0.txt</title>
<meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
<link href='../../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
<script type='text/javascript'>
  function popupCode(url) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }
  
  function toggleCode(id) {
    var code = document.getElementById(id)
  
    code.style.display = code.style.display != 'block' ? 'block' : 'none'
    return true
  }
  
  // Make codeblocks hidden by default
  document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
</script>
</head>
<body class='page'>
<div class='file' id='wrapper'>
<div class='header'>
<h1 class='name'>3.19.0.txt
</h1>
<div class='paths'>
doc/release_notes/3.19.0.txt
</div>
<div class='last-update'>
Last Update:
<span class='datetime'>2019-04-12 07:25:27 -0700</span>
</div>
</div>
<div id='content'>
<div id='text'>
<div id='description'>
<h1 id="label-New+Features">New Features<span><a href="#label-New+Features">&para;</a> <a href="#top">&uarr;</a></span></h1>
<ul><li>
<p>A hash_routes plugin has been added for O(1) route dispatching at any level of the routing tree.  By default, <a href="../../../classes/Roda.html"><code>Roda</code></a> uses a linear search of possible branches at each level of the routing tree, which results in roughly O(log(n)) routing behavior in most applications (where n is the total number of routes in the application).</p>

<p>Assume you have the following routing tree:</p>

<pre class="ruby"><span class="ruby-identifier">route</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-identifier">r</span>.<span class="ruby-identifier">on</span> <span class="ruby-string">&quot;a&quot;</span> <span class="ruby-keyword">do</span>&#x000A;    <span class="ruby-comment"># ...</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;&#x000A;  <span class="ruby-identifier">r</span>.<span class="ruby-identifier">on</span> <span class="ruby-string">&quot;b&quot;</span> <span class="ruby-keyword">do</span>&#x000A;    <span class="ruby-comment"># ...</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;&#x000A;  <span class="ruby-identifier">r</span>.<span class="ruby-identifier">is</span> <span class="ruby-string">&quot;c&quot;</span> <span class="ruby-keyword">do</span>&#x000A;    <span class="ruby-comment"># ...</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;&#x000A;  <span class="ruby-comment"># ...</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<p>With this routing tree, a request for /c will first check /a and /b.  This is not normally a performance issue, but if you have a large number of routes at a particular level, it can be.</p>

<p>The hash_routes plugin allows you to convert this routing tree to:</p>

<pre class="ruby"><span class="ruby-identifier">plugin</span> <span class="ruby-value">:hash_routes</span>&#x000A;&#x000A;<span class="ruby-identifier">hash_routes</span> <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">on</span> <span class="ruby-string">&quot;a&quot;</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-comment"># ...</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;&#x000A;  <span class="ruby-identifier">on</span> <span class="ruby-string">&quot;b&quot;</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-comment"># ...</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;&#x000A;  <span class="ruby-identifier">is</span> <span class="ruby-string">&quot;c&quot;</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-comment"># ...</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;&#x000A;  <span class="ruby-comment"># ...</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-identifier">route</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-identifier">r</span>.<span class="ruby-identifier">hash_routes</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<p>This routing tree looks similar to Roda&#39;s standard routing tree, and will have the same behavior as the previous example, but dispatching to the routes inside the hash_routes block by the r.hash_routes method will be an O(1) operation, instead of a linear search.  This can significantly improve performance in cases where you have a large number of branches at any point in the routing tree.</p>

<p>In order to support O(1) route dispatching at any level of the tree, the hash_routes plugin supports namespaces.  You can use this namespace support to keep the primary advantage of <a href="../../../classes/Roda.html"><code>Roda</code></a> when using the hash_routes plugin, which is the ability to operate on a request at any point during routing.  Assume you have this routing tree:</p>

<pre class="ruby"><span class="ruby-identifier">hash_routes</span> <span class="ruby-value">:root</span> <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">on</span> <span class="ruby-string">&quot;foo&quot;</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-identifier">r</span>.<span class="ruby-identifier">on</span> <span class="ruby-constant">Integer</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">foo_id</span><span class="ruby-operator">|</span>&#x000A;      <span class="ruby-keyword">next</span> <span class="ruby-keyword">unless</span> <span class="ruby-ivar">@foo</span> = <span class="ruby-constant">Foo</span>[<span class="ruby-identifier">foo_id</span>]&#x000A;      <span class="ruby-identifier">r</span>.<span class="ruby-identifier">hash_routes</span>(<span class="ruby-value">:foo</span>)&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;&#x000A;  <span class="ruby-identifier">on</span> <span class="ruby-string">&quot;bar&quot;</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-identifier">r</span>.<span class="ruby-identifier">on</span> <span class="ruby-constant">Integer</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">bar_id</span><span class="ruby-operator">|</span>&#x000A;      <span class="ruby-keyword">next</span> <span class="ruby-keyword">unless</span> <span class="ruby-ivar">@bar</span> = <span class="ruby-constant">Bar</span>[<span class="ruby-identifier">bar_id</span>]&#x000A;      <span class="ruby-identifier">r</span>.<span class="ruby-identifier">hash_routes</span>(<span class="ruby-value">:bar</span>)&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;&#x000A;  <span class="ruby-comment"># ...</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-identifier">hash_routes</span> <span class="ruby-value">:foo</span> <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">get</span> <span class="ruby-string">&quot;show&quot;</span> <span class="ruby-keyword">do</span>&#x000A;    <span class="ruby-ivar">@page_title</span> = <span class="ruby-ivar">@foo</span>.<span class="ruby-identifier">name</span>&#x000A;    <span class="ruby-identifier">view</span>(<span class="ruby-string">&#39;foo/show&#39;</span>)&#x000A;  <span class="ruby-keyword">end</span>&#x000A;&#x000A;  <span class="ruby-comment"># ...</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-identifier">hash_routes</span> <span class="ruby-value">:bar</span> <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">post</span> <span class="ruby-string">&quot;edit&quot;</span> <span class="ruby-keyword">do</span>&#x000A;    <span class="ruby-ivar">@bar</span>.<span class="ruby-identifier">update</span>(<span class="ruby-value">:name</span><span class="ruby-operator">=&gt;</span><span class="ruby-identifier">request</span>.<span class="ruby-identifier">params</span>[<span class="ruby-string">&#39;name&#39;</span>])&#x000A;    <span class="ruby-identifier">r</span>.<span class="ruby-identifier">redirect</span> <span class="ruby-string">&quot;/&quot;</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;&#x000A;  <span class="ruby-comment"># ...</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-identifier">route</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-identifier">r</span>.<span class="ruby-identifier">hash_routes</span>(<span class="ruby-value">:root</span>)&#x000A;<span class="ruby-keyword">end</span></pre>

<p>With this routing tree, a GET /foo/123/show request will first get dispatched to the on “foo” block in the :root namespace.  That will extract the 123 segment from the path, and use it to find the Foo object with id 123 and set that to the instance variable @foo. If there is no matching foo, the rest of the block will be skipped, which will result in a 404 response.  If there is a matching foo, after setting the instance variable, it will dispatch to routes in the :foo namespace, one of which is show, which will be able to use the @foo variable, both in the route and in the view.</p>

<p>Similarly, a POST /bar/321/edit request would dispatch to the on “bar” block in the :root namespace, will look up the matching bar, then will dispatch to the edit route in the :bar namespace.</p>

<p>The hash_routes plugin can be used as a faster version of the multi_route plugin&#39;s r.multi_route method.  It can also be used as a faster replacement for the multi_view plugin.</p>

<p>Please see the hash_routes plugin documentation for additional methods and configuration styles supported by the plugin.</p>
</li><li>
<p>A match_hook plugin has been added, which is called for each successful match, before yielding to the match block.  For example, with the following routing tree:</p>

<pre class="ruby"><span class="ruby-identifier">plugin</span> <span class="ruby-value">:match_hook</span>&#x000A;&#x000A;<span class="ruby-identifier">match_hook</span> <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;#{r.matched_path}|#{r.remaining_path}&quot;</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-identifier">route</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-identifier">r</span>.<span class="ruby-identifier">on</span> <span class="ruby-string">&quot;a&quot;</span> <span class="ruby-keyword">do</span>&#x000A;    <span class="ruby-identifier">r</span>.<span class="ruby-identifier">is</span> <span class="ruby-string">&quot;b&quot;</span> <span class="ruby-keyword">do</span>&#x000A;      <span class="ruby-identifier">r</span>.<span class="ruby-identifier">get</span> <span class="ruby-keyword">do</span>&#x000A;      <span class="ruby-keyword">end</span>&#x000A;&#x000A;      <span class="ruby-identifier">r</span>.<span class="ruby-identifier">post</span> <span class="ruby-keyword">do</span>&#x000A;      <span class="ruby-keyword">end</span>&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<p>A GET request for /a/b would call the match hook three times, and output the following:</p>

<pre>/a|/b # When the r.on block matches&#x000A;/a/b| # When the r.is block matches&#x000A;/a/b| # When the r.get block matches</pre>

<p>A GET request for /a/c would call the match hook once, and output the following:</p>

<pre>/a|/b # When the r.on block matches</pre>

<p>This plugin can be used to make debugging easier, as well as for metrics.</p>
</li></ul>

<h1 id="label-Other+Improvements">Other Improvements<span><a href="#label-Other+Improvements">&para;</a> <a href="#top">&uarr;</a></span></h1>
<ul><li>
<p>Per-cookie cipher secrets are now supported and used automatically by default in the sessions plugin.  This can prevent issues where the cipher secret can be leaked if the random initialization vector turns out not to be so random and ends up being reused.  This makes the session cookies slightly larger and about 10-20% slower.</p>

<p>Note that because of the way the sessions plugin is designed, even if the cipher secret was leaked and you are not using per-cookie cipher secrets, it would not allow an attacker to forge a session, it would only allow them to read the contents of an existing session.</p>

<p>If you are currently using the sessions plugin, and performing rolling restarts, you should temporarily disable per-cookie session secrets until all processes have been restarted and are able to support per-cookie session secrets.  You can do so by setting the :per_cookie_cipher_secret sessions plugin option to false temporarily until all processes have restarted and are running <a href="../../../classes/Roda.html"><code>Roda</code></a> 3.19.0+.</p>
</li><li>
<p>When passing route blocks to <a href="../../../classes/Roda.html"><code>Roda</code></a> that have 0 arity instead of the expected arity of 1, emulate an arity of 1 using an approach that is about 2.75-8x faster.  This emulation is still about 20% slower than using the expected arity.</p>
</li><li>
<p>Fix emulation of route blocks that have &gt;1 arity but where the expected arity is 1.  Such blocks were not handled correctly in <a href="../../../classes/Roda.html"><code>Roda</code></a> 3.18.0.</p>
</li><li>
<p>String matching performance has been improved by 10-20%.</p>
</li><li>
<p>Symbol and String class matching performance has improved by 10-20%.</p>
</li><li>
<p>Terminal matching performance has improved by about 4x.</p>
</li><li>
<p><a href="../../../classes/Roda.html"><code>Roda</code></a> will now automatically load the direct_call plugin when freezing the application if there is no middleware used and the application has not been subclassed, for improved performance.</p>
</li><li>
<p><a href="../../../classes/Roda.html"><code>Roda</code></a> no longer builds the rack application until the app class method is called.  This can fix O(n^2) issues when building applications with a lot of middleware.  One consequence of this is that a Roda.route block is no longer required. If Roda.route is not called, then the default routing tree will return a 404 response for all requests.</p>

<p>The delay_build plugin used to support delaying building the rack application until a build! method is called.  Now that <a href="../../../classes/Roda.html"><code>Roda</code></a> delays building the rack application until the app method is called, there is no reason to use this plugin, and it is now a no-op.</p>
</li><li>
<p>The assets plugin :timestamp_paths option now supports a string value to use a custom separator. A slash separator is still used by default.</p>
</li></ul>

<h1 id="label-Backwards+Compatibility">Backwards Compatibility<span><a href="#label-Backwards+Compatibility">&para;</a> <a href="#top">&uarr;</a></span></h1>
<ul><li>
<p>The static_routing plugin internals have changed, as the static_routing is now implemented via the hash_routes plugin.  If you were depending on the internals, you will need to update your code.</p>
</li></ul>
</div>
<div id='context'>
</div>

</div>
</div>

<div id='footer-push'></div>
</div>
<div id='footer'>
<a href="https://github.com/rdoc/hanna-nouveau"><strong>Hanna Nouveau</strong> RDoc template</a>
</div>
</body>
</html>
