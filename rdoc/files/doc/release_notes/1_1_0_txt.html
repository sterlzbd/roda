<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
  <head>
    <title>1.1.0.txt</title>
    <meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
    <link href='../../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
    <script type='text/javascript'>
      //<![CDATA[
        function popupCode(url) {
          window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
        }
        
        function toggleCode(id) {
          var code = document.getElementById(id)
        
          code.style.display = code.style.display != 'block' ? 'block' : 'none'
          return true
        }
        
        // Make codeblocks hidden by default
        document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
      //]]>
    </script>
  </head>
  <body class='page'>
    <div class='file' id='wrapper'>
      <div class='header'>
        <h1 class='name'>1.1.0.txt</h1>
        <div class='paths'>
          doc/release_notes/1.1.0.txt
        </div>
        <div class='last-update'>
          Last Update:
          <span class='datetime'>2014-11-11 11:35:26 -0800</span>
        </div>
      </div>
      <div id='content'>
        <div id='text'>
          <div id='description'>
            
            <h1 id="label-New+Plugins">New Plugins<span><a href="#label-New+Plugins">&para;</a> <a href="#documentation">&uarr;</a></span></h1>
            <ul><li>
            <p>An assets plugin has been added, for rendering your CSS and javascript
            asset files on the fly in development, and compiling them to a single,
            compressed file in production.</p>
            
            <p>When loading the plugin, you just specify the assets to use via :css and/or
            :js options:</p>
            
            <pre class="ruby"><span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">assets</span>, :<span class="ruby-identifier">css=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">&#39;some_file.scss&#39;</span>, :<span class="ruby-identifier">js=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">&#39;some_file.coffee&#39;</span></pre>
            
            <p>Inside your Roda.route block, you call r.assets to serve the assets:</p>
            
            <pre class="ruby"><span class="ruby-identifier">route</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-identifier">r</span>.<span class="ruby-identifier">assets</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>In your views, you can call the assets method, which returns strings
            containing link/script tags for your assets:</p>
            
            <pre>&lt;%= assets(:css) %&gt;&#x000A;&lt;%= assets(:js) %&gt;</pre>
            
            <p>In production mode, you call compile_assets after loading the plugin, and
            it will compile all of the asset files into a single file per type,
            optionally compress it (using yuicompressor), and write the file to the
            public folder where it can be served by the webserver.  In compiled mode,
            calling assets in your views will reference the compiled file.</p>
            
            <p>It&#39;s possible to precompile your assets before application boot, so
            they don&#39;t need to be compiled every time your application boots.</p>
            
            <p>The assets plugin also supports asset groups, useful when different
            sections of your application use different sets of assets.</p>
            </li><li>
            <p>A chunked plugin has been added, for streaming template rendering using
            Transfer-Encoding: chunked.  By default, this flushes the rendering of the
            top part of the layout template before rendering the content template,
            allowing the client to load the assets necessary to fully render the page
            while the content template is still being rendered on the server.  This can
            significantly decrease client rendering times.</p>
            
            <p>To use chunked encoding for a response, just call the chunked method
            instead of view:</p>
            
            <pre class="ruby"><span class="ruby-identifier">r</span>.<span class="ruby-identifier">root</span> <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">chunked</span>(:<span class="ruby-identifier">index</span>)&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>If you want to execute code after flushing the top part of the layout
            template, but before rendering the content template, pass a block to
            chunked:</p>
            
            <pre class="ruby"><span class="ruby-identifier">r</span>.<span class="ruby-identifier">root</span> <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">chunked</span>(:<span class="ruby-identifier">index</span>) <span class="ruby-keyword">do</span>&#x000A;    <span class="ruby-comment"># expensive calculation here</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>If you want to use chunked encoding for all responses, pass the
            :chunk_by_default option when loading the plugin:</p>
            
            <pre class="ruby"><span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">chunked</span>, :<span class="ruby-identifier">chunk_by_default</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span></pre>
            
            <p>Inside your layout or content templates, you can call the flush method to
            flush the current result of the template to the user, useful for streaming
            large datasets.</p>
            
            <pre>&lt;% (1..100).each do |i| %&gt;&#x000A;  &lt;%= i %&gt;&#x000A;  &lt;% sleep 0.1 %&gt;&#x000A;  &lt;% flush %&gt;&#x000A;&lt;% end %&gt;</pre>
            </li><li>
            <p>A caching plugin has been added, for simple HTTP caching support. The
            implementation is based on Sinatra&#39;s, and offers r.last_modifed and
            r.etag methods for conditional responses:</p>
            
            <pre class="ruby"><span class="ruby-identifier">r</span>.<span class="ruby-identifier">get</span> <span class="ruby-string">&#39;/albums/:d&#39;</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">album_id</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-ivar">@album</span> = <span class="ruby-constant">Album</span>[<span class="ruby-identifier">album_id</span>]&#x000A;  <span class="ruby-identifier">r</span>.<span class="ruby-identifier">last_modified</span> <span class="ruby-ivar">@album</span>.<span class="ruby-identifier">updated_at</span>&#x000A;  <span class="ruby-identifier">r</span>.<span class="ruby-identifier">etag</span> <span class="ruby-ivar">@album</span>.<span class="ruby-identifier">sha1</span>&#x000A;  <span class="ruby-identifier">view</span>(<span class="ruby-string">&#39;album&#39;</span>)&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>This also adds response.cache_control and response.expires methods for
            setting the Cache-Control/Expires headers for the response.</p>
            </li><li>
            <p>A path plugin has been added for simple support for named paths:</p>
            
            <pre class="ruby"><span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">path</span>&#x000A;<span class="ruby-identifier">path</span> :<span class="ruby-identifier">foo</span>, <span class="ruby-string">&#39;/foo&#39;</span>   <span class="ruby-comment"># foo_path =&gt; &#39;/foo&#39;</span>&#x000A;<span class="ruby-identifier">path</span> :<span class="ruby-identifier">bar</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">bar</span><span class="ruby-operator">|</span>  <span class="ruby-comment"># bar_path(bar) =&gt; &#39;/bar/1&#39;</span>&#x000A;  <span class="ruby-node">&quot;/bar/#{bar.id}&quot;</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            </li><li>
            <p>An error_email plugin has been added, for easily emailing error
            notifications for an exception.  This is designed for use with the
            error_handler plugin, and should only be used in low-traffic environments:</p>
            
            <pre class="ruby"><span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">error_email</span>, :<span class="ruby-identifier">to=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">&#39;to@example.com&#39;</span>,&#x000A;                     :<span class="ruby-identifier">from=</span><span class="ruby-operator">&gt;</span><span class="ruby-string">&#39;from@example.com&#39;</span>&#x000A;<span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">error_handler</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-identifier">error_email</span>(<span class="ruby-identifier">e</span>)&#x000A;  <span class="ruby-string">&#39;Internal Server Error&#39;</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            </li></ul>
            
            <h1 id="label-multi_route+Plugin+Improvements">multi_route Plugin Improvements<span><a href="#label-multi_route+Plugin+Improvements">&para;</a> <a href="#documentation">&uarr;</a></span></h1>
            <ul><li>
            <p>The multi_route plugin now supports namespaces, allowing it to support
            routing trees of arbitrary complexity.  Previously, only a single namespace
            was supported. For example, if you want to store your named routes in a
            directory tree:</p>
            
            <pre>/routes/foo.rb&#x000A;/routes/foo/baz.rb&#x000A;/routes/foo/quux.rb&#x000A;/routes/bar.rb&#x000A;/routes/bar/baz.rb&#x000A;/routes/bar/quux.rb</pre>
            
            <p>You can load all of the routing files in the routes subdirectory tree, and
            structure your routing tree as follows:</p>
            
            <pre class="ruby"><span class="ruby-comment"># app.rb</span>&#x000A;<span class="ruby-identifier">route</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-identifier">r</span>.<span class="ruby-identifier">multi_route</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-comment"># routes/foo.rb</span>&#x000A;<span class="ruby-identifier">route</span>(<span class="ruby-string">&#39;foo&#39;</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-identifier">check_foo_access!</span>&#x000A;  <span class="ruby-identifier">r</span>.<span class="ruby-identifier">multi_route</span>(<span class="ruby-string">&#39;foo&#39;</span>)&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-comment"># routes/bar.rb</span>&#x000A;<span class="ruby-identifier">route</span>(<span class="ruby-string">&#39;bar&#39;</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-identifier">check_bar_access!</span>&#x000A;  <span class="ruby-identifier">r</span>.<span class="ruby-identifier">multi_route</span>(<span class="ruby-string">&#39;bar&#39;</span>)&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-comment"># routes/foo/baz.rb</span>&#x000A;<span class="ruby-identifier">route</span>(<span class="ruby-string">&#39;baz&#39;</span>, <span class="ruby-string">&#39;foo&#39;</span>) <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-comment"># ...</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            </li><li>
            <p>Newly added named routes are now picked up while running, useful in
            development when using code reloading.</p>
            </li><li>
            <p>r.multi_route now ignores non-String named routes, allowing you to only
            dispatch to the String named routes.  Previously, calling r.multi_route
            when any non-String names routes were present resulted in an error.</p>
            </li><li>
            <p>r.multi_route now prefers longer routes to shorter routes if routes have
            the same prefix.  This can fix behavior if you have named routes such as
            “foo” and “foo/bar”.</p>
            </li><li>
            <p>If you don&#39;t pass a block to r.multi_route, it will use the return
            value of the named route as the block value to return, instead of always
            returning nil.</p>
            </li></ul>
            
            <h1 id="label-Optimizations">Optimizations<span><a href="#label-Optimizations">&para;</a> <a href="#documentation">&uarr;</a></span></h1>
            <ul><li>
            <p>Dispatch speed is slightly improved by using allocate instead of new to
            create new instances.</p>
            </li><li>
            <p>Hash allocations in the render plugin have been reduced.</p>
            </li></ul>
            
            <h1 id="label-Other+Improvements">Other Improvements<span><a href="#label-Other+Improvements">&para;</a> <a href="#documentation">&uarr;</a></span></h1>
            <ul><li>
            <p>The Roda.route block is now inherited when subclassing, making it possible
            to subclass a <a href="../../../classes/Roda.html">Roda</a> application and
            have the subclass work without adding a route block.</p>
            </li><li>
            <p>Middleware added to a <a href="../../../classes/Roda.html">Roda</a> app
            after the Roda.route method is called are now used instead of being
            ignored.</p>
            </li><li>
            <p>A response.finish_with_body method has been added, for overriding the
            response body to use.  This is useful if you want to support arbitrary
            response bodies.</p>
            </li><li>
            <p>The render plugin now defaults the locals argument to an empty frozen hash
            instead of nil when rendering templates via tilt. This is faster as it
            avoids a hash allocation inside tilt, and also works with broken external
            tilt templates that require that the locals argument be a hash.</p>
            </li><li>
            <p>Plugins that ship with <a href="../../../classes/Roda.html">Roda</a> no
            longer set constants inside InstanceMethods.  Instead, the constants are
            set at the plugin module level.  This is done to avoid polluting the
            namespace of the application with the constants.  Roda&#39;s policy is that
            all internal constants inside the <a
            href="../../../classes/Roda.html">Roda</a> namespace are prefixed with <a
            href="../../../classes/Roda.html">Roda</a>, so they don&#39;t pollute the
            user&#39;s namespace, and setting these constants inside InstanceMethods in
            plugins violated that policy.</p>
            </li></ul>
            
            <h1 id="label-Backwards+Compatibility">Backwards Compatibility<span><a href="#label-Backwards+Compatibility">&para;</a> <a href="#documentation">&uarr;</a></span></h1>
            <ul><li>
            <p>response.write no longer sets a Content-Length header.  Instead,
            response.finish sets it.  This is faster if you call response.write
            multiple times, and more correct if you call response.finish without
            calling response.write.</p>
            </li><li>
            <p>In the render plugin, modifying render_opts directly is now deprecated and
            will raise an error in the next major release (the hash will be frozen). 
            Instead, users should call plugin :render again with a new hash, which will
            be merged into the existing render_opts hash.</p>
            </li><li>
            <p>Moving plugin&#39;s constants from InstanceMethods to the plugin level can
            break applications where the constant was referenced directly. For example,
            if you were doing:</p>
            
            <pre class="ruby"><span class="ruby-constant">Roda</span><span class="ruby-operator">::</span><span class="ruby-constant">SESSION_KEY</span></pre>
            
            <p>to get the constant for the session key, you would now need to use:</p>
            
            <pre class="ruby"><span class="ruby-constant">Roda</span><span class="ruby-operator">::</span><span class="ruby-constant">RodaPlugins</span><span class="ruby-operator">::</span><span class="ruby-constant">Base</span><span class="ruby-operator">::</span><span class="ruby-constant">SESSION_KEY</span></pre>
            
            <p>In general, it is recommended to not reference such constants at all.  If
            you think there should be a general reason to access them, request that a
            method is added that returns them.</p>
            </li></ul>
          </div>
          <div id='context'>
          </div>
        </div>
      </div>
      <div id='footer-push'></div>
    </div>
    <div id='footer'>
      <a target="docwin" href="http://github.com/mislav/hanna/tree/master"><strong>Hanna</strong> RDoc template</a>
    </div>
  </body>
</html>
