<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
  <head>
    <title>2.16.0.txt</title>
    <meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
    <link href='../../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
    <script type='text/javascript'>
      //<![CDATA[
        function popupCode(url) {
          window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
        }
        
        function toggleCode(id) {
          var code = document.getElementById(id)
        
          code.style.display = code.style.display != 'block' ? 'block' : 'none'
          return true
        }
        
        // Make codeblocks hidden by default
        document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
      //]]>
    </script>
  </head>
  <body class='page'>
    <div class='file' id='wrapper'>
      <div class='header'>
        <h1 class='name'>2.16.0.txt</h1>
        <div class='paths'>
          doc/release_notes/2.16.0.txt
        </div>
        <div class='last-update'>
          Last Update:
          <span class='datetime'>2016-07-13 08:09:00 -0700</span>
        </div>
      </div>
      <div id='content'>
        <div id='text'>
          <div id='description'>
            
            <h1 id="label-New+Features">New Features<span><a href="#label-New+Features">&para;</a> <a href="#top">&uarr;</a></span></h1>
            <ul><li>
            <p>A type_routing plugin has been added.  This plugin allows routing based on
            the requested type, which can be submitted either via a file extension or
            Accept header:</p>
            
            <pre class="ruby"><span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">type_routing</span>&#x000A;&#x000A;<span class="ruby-identifier">route</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-identifier">r</span>.<span class="ruby-identifier">get</span> <span class="ruby-string">&#39;a&#39;</span> <span class="ruby-keyword">do</span>&#x000A;    <span class="ruby-identifier">r</span>.<span class="ruby-identifier">html</span>{ <span class="ruby-string">&quot;&lt;h1&gt;This is the HTML response&lt;/h1&gt;&quot;</span> }&#x000A;    <span class="ruby-identifier">r</span>.<span class="ruby-identifier">json</span>{ <span class="ruby-string">&#39;{&quot;json&quot;: &quot;ok&quot;}&#39;</span> }&#x000A;    <span class="ruby-identifier">r</span>.<span class="ruby-identifier">xml</span>{ <span class="ruby-string">&quot;&lt;root&gt;This is the XML response&lt;/root&gt;&quot;</span> }&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-comment"># /a or /a.html =&gt; HTML response</span>&#x000A;<span class="ruby-comment"># /a.json =&gt; JSON response</span>&#x000A;<span class="ruby-comment"># /a.xml =&gt; XML response</span></pre>
            
            <p>The response content type is set appropriately when the r.html, r.json, or
            r.xml block is yielded to.  Using plugin options, you can add support for
            custom types, and choose whether to use only file extensions or only Accept
            headers for type matching.</p>
            </li><li>
            <p>A request_headers plugin has been added. This allows easier access to
            request headers.  For example, to access a header called X-My-Header, by
            default you would need to use the CGI mangled name:</p>
            
            <pre class="ruby"><span class="ruby-identifier">r</span>.<span class="ruby-identifier">env</span>[<span class="ruby-string">&#39;HTTP_X_MY_HEADER&#39;</span>]</pre>
            
            <p>The request_headers plugin allows the easier to use:</p>
            
            <pre class="ruby"><span class="ruby-identifier">r</span>.<span class="ruby-identifier">headers</span>[<span class="ruby-string">&#39;X-My-Header&#39;</span>]</pre>
            </li><li>
            <p>An unescape_path plugin has been added.  By default, <a
            href="../../../classes/Roda.html">Roda</a> does not unescape a URL-encoded
            PATH_INFO before routing.  This plugin allows URL-encoded PATH_INFO to
            work, supporting %2f as well as / as path separators, and having captures
            return unescaped values:</p>
            
            <pre class="ruby"><span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">unescape_path</span>&#x000A;&#x000A;<span class="ruby-identifier">route</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-comment"># Assume /b/a URL encoded at %2f%62%2f%61</span>&#x000A;  <span class="ruby-identifier">r</span>.<span class="ruby-identifier">on</span> :<span class="ruby-identifier">x</span>, <span class="ruby-regexp">/(.)/</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-operator">*</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-comment"># x =&gt; [&#39;b&#39;, &#39;a&#39;]</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            </li></ul>
          </div>
          <div id='context'>
          </div>
        </div>
      </div>
      <div id='footer-push'></div>
    </div>
    <div id='footer'>
      <a target="docwin" href="http://github.com/mislav/hanna/tree/master"><strong>Hanna</strong> RDoc template</a>
    </div>
  </body>
</html>
