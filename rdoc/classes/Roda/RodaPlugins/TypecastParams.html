<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
<head>
<title>Roda::RodaPlugins::TypecastParams</title>
<meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
<link href='../../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
<script type='text/javascript'>
  function popupCode(url) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }
  
  function toggleCode(id) {
    var code = document.getElementById(id)
  
    code.style.display = code.style.display != 'block' ? 'block' : 'none'
    return true
  }
  
  // Make codeblocks hidden by default
  document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
</script>
</head>
<body class='page'>
<div class='class' id='wrapper'>
<div class='header'>
<h1 class='name'><span class='type'>module</span>
Roda::RodaPlugins::TypecastParams
</h1>
<ol class='paths'>
<li>
<a href="../../../files/lib/roda/plugins/typecast_params_rb.html">lib/roda/plugins/typecast_params.rb</a>
</li>
</ol>
</div>
<div id='content'>
<div id='text'>
<div id='description'>
<p>The typecast_params plugin allows for the simple type conversion for
submitted parameters.  Submitted parameters should be considered untrusted
input, and in standard use with browsers, parameters are submitted as
strings (or a hash/array containing strings).  In most cases it makes sense
to explicitly convert the parameter to the desired type.  While this can be
done via manual conversion:</p>

<pre class="ruby"><span class="ruby-identifier">key</span> = <span class="ruby-identifier">request</span>.<span class="ruby-identifier">params</span>[<span class="ruby-string">&#39;key&#39;</span>].<span class="ruby-identifier">to_i</span>&#x000A;<span class="ruby-identifier">key</span> = <span class="ruby-keyword">nil</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">key</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span></pre>

<p>the typecast_params plugin adds a friendlier interface:</p>

<pre class="ruby"><span class="ruby-identifier">key</span> = <span class="ruby-identifier">typecast_params</span>.<span class="ruby-identifier">pos_int</span>(<span class="ruby-string">&#39;key&#39;</span>)</pre>

<p>As <code>typecast_params</code> is a fairly long method name, you may want
to consider aliasing it to something more terse in your application, such
as <code>tp</code>.</p>

<p>One advantage of using typecast_params is that access or conversion errors
are raised as a specific exception class
(<code>Roda::RodaPlugins::TypecastParams::Error</code>).  This allows you
to handle this specific exception class globally and return an appropriate
4xx response to the client.  You can use the <a
href="TypecastParams/Error.html#method-i-param_name">Roda::RodaPlugins::TypecastParams::Error#param_name</a>
and <a
href="TypecastParams/Error.html#attribute-i-reason">Roda::RodaPlugins::TypecastParams::Error#reason</a>
methods to get more information about the error.</p>

<p>typecast_params offers support for default values:</p>

<pre class="ruby"><span class="ruby-identifier">key</span> = <span class="ruby-identifier">typecast_params</span>.<span class="ruby-identifier">pos_int</span>(<span class="ruby-string">&#39;key&#39;</span>, <span class="ruby-value">1</span>)</pre>

<p>The default value is only used if no value has been submitted for the
parameter, or if the conversion of the value results in <code>nil</code>. 
Handling defaults for parameter conversion manually is more difficult,
since the parameter may not be present at all, or it may be present but an
empty string because the user did not enter a value on the related form. 
Use of typecast_params for the conversion handles both cases.</p>

<p>In many cases, parameters should be required, and if they aren&#39;t
submitted, that should be considered an error.  typecast_params handles
this with ! methods:</p>

<pre class="ruby"><span class="ruby-identifier">key</span> = <span class="ruby-identifier">typecast_params</span>.<span class="ruby-identifier">pos_int!</span>(<span class="ruby-string">&#39;key&#39;</span>)</pre>

<p>These ! methods raise an error instead of returning <code>nil</code>, and
do not allow defaults.</p>

<p>To make it easy to handle cases where many parameters need the same
conversion done, you can pass an array of keys to a conversion method, and
it will return an array of converted values:</p>

<pre class="ruby"><span class="ruby-identifier">key1</span>, <span class="ruby-identifier">key2</span> = <span class="ruby-identifier">typecast_params</span>.<span class="ruby-identifier">pos_int</span>([<span class="ruby-string">&#39;key1&#39;</span>, <span class="ruby-string">&#39;key2&#39;</span>])</pre>

<p>This is equivalent to:</p>

<pre class="ruby"><span class="ruby-identifier">key1</span> = <span class="ruby-identifier">typecast_params</span>.<span class="ruby-identifier">pos_int</span>(<span class="ruby-string">&#39;key1&#39;</span>)&#x000A;<span class="ruby-identifier">key2</span> = <span class="ruby-identifier">typecast_params</span>.<span class="ruby-identifier">pos_int</span>(<span class="ruby-string">&#39;key2&#39;</span>)</pre>

<p>The ! methods also support arrays, ensuring that all parameters have a
value:</p>

<pre class="ruby"><span class="ruby-identifier">key1</span>, <span class="ruby-identifier">key2</span> = <span class="ruby-identifier">typecast_params</span>.<span class="ruby-identifier">pos_int!</span>([<span class="ruby-string">&#39;key1&#39;</span>, <span class="ruby-string">&#39;key2&#39;</span>])</pre>

<p>For handling of array parameters, where all entries in the array use the
same conversion, there is an <code>array</code> method which takes the type
as the first argument and the keys to convert as the second argument:</p>

<pre class="ruby"><span class="ruby-identifier">keys</span> = <span class="ruby-identifier">typecast_params</span>.<span class="ruby-identifier">array</span>(<span class="ruby-value">:pos_int</span>, <span class="ruby-string">&#39;keys&#39;</span>)</pre>

<p>If you want to ensure that all entries in the array are converted
successfully and that there is a value for the array itself, you can use
<code>array!</code>:</p>

<pre class="ruby"><span class="ruby-identifier">keys</span> = <span class="ruby-identifier">typecast_params</span>.<span class="ruby-identifier">array!</span>(<span class="ruby-value">:pos_int</span>, <span class="ruby-string">&#39;keys&#39;</span>)</pre>

<p>This will raise an exception if any of the values in the array for
parameter <code>keys</code> cannot be converted to integer.</p>

<p>Both <code>array</code> and <code>array!</code> support default values
which are used if no value is present for the parameter:</p>

<pre class="ruby"><span class="ruby-identifier">keys</span> = <span class="ruby-identifier">typecast_params</span>.<span class="ruby-identifier">array</span>(<span class="ruby-value">:pos_int</span>, <span class="ruby-string">&#39;keys&#39;</span>, [])&#x000A;<span class="ruby-identifier">keys</span> = <span class="ruby-identifier">typecast_params</span>.<span class="ruby-identifier">array!</span>(<span class="ruby-value">:pos_int</span>, <span class="ruby-string">&#39;keys&#39;</span>, [])</pre>

<p>You can also pass an array of keys to <code>array</code> or
<code>array!</code>, if you would like to perform the same conversion on
multiple arrays:</p>

<pre class="ruby"><span class="ruby-identifier">foo_ids</span>, <span class="ruby-identifier">bar_ids</span> = <span class="ruby-identifier">typecast_params</span>.<span class="ruby-identifier">array!</span>(<span class="ruby-value">:pos_int</span>, [<span class="ruby-string">&#39;foo_ids&#39;</span>, <span class="ruby-string">&#39;bar_ids&#39;</span>])</pre>

<p>The previous examples have shown use of the <code>pos_int</code> method,
which uses <code>to_i</code> to convert the value to an integer, but
returns nil if the resulting integer is not positive.  Unless you need to
handle negative numbers, it is recommended to use <code>pos_int</code>
instead of <code>int</code> as <code>int</code> will convert invalid values
to 0 (since that is how <code>String#to_i</code> works).</p>

<p>There are many built in methods for type conversion:</p>
<table class="rdoc-list note-list"><tbody><tr><td class='label'>any </td><td>
<p>Returns the value as is without conversion</p>
</td></tr><tr><td class='label'>str </td><td>
<p>Raises if value is not already a string</p>
</td></tr><tr><td class='label'>nonempty_str </td><td>
<p>Raises if value is not already a string, and converts the empty string or
string containing only whitespace to <code>nil</code></p>
</td></tr><tr><td class='label'>bool </td><td>
<p>Converts entry to boolean if in one of the recognized formats:</p>
<table class="rdoc-list note-list"><tbody><tr><td class='label'>nil </td><td>
<p>nil, &#39;&#39;</p>
</td></tr><tr><td class='label'>true </td><td>
<p>true, 1, &#39;1&#39;, &#39;t&#39;, &#39;true&#39;, &#39;yes&#39;,
&#39;y&#39;, &#39;on&#39; # case insensitive</p>
</td></tr><tr><td class='label'>false </td><td>
<p>false, 0, &#39;0&#39;, &#39;f&#39;, &#39;false&#39;, &#39;no&#39;,
&#39;n&#39;, &#39;off&#39; # case insensitive</p>
</td></tr></tbody></table>

<p>If not in one of those formats, raises an error.</p>
</td></tr><tr><td class='label'>int </td><td>
<p>Converts value to integer using <code>to_i</code> (note that invalid input
strings will be returned as 0)</p>
</td></tr><tr><td class='label'>pos_int </td><td>
<p>Converts value using <code>to_i</code>, but non-positive values are
converted to <code>nil</code></p>
</td></tr><tr><td class='label'>Integer </td><td>
<p>Converts value to integer using <code>Kernel::Integer(value, 10)</code></p>
</td></tr><tr><td class='label'>float </td><td>
<p>Converts value to float using <code>to_f</code> (note that invalid input
strings will be returned as 0.0)</p>
</td></tr><tr><td class='label'>Float </td><td>
<p>Converts value to float using <code>Kernel::Float(value)</code></p>
</td></tr><tr><td class='label'>Hash </td><td>
<p>Raises if value is not already a hash</p>
</td></tr><tr><td class='label'>date </td><td>
<p>Converts value to Date using <code>Date.parse(value)</code></p>
</td></tr><tr><td class='label'>time </td><td>
<p>Converts value to Time using <code>Time.parse(value)</code></p>
</td></tr><tr><td class='label'>datetime </td><td>
<p>Converts value to DateTime using <code>DateTime.parse(value)</code></p>
</td></tr><tr><td class='label'>file </td><td>
<p>Raises if value is not already a hash with a :tempfile key whose value
responds to <code>read</code> (this is the format rack uses for uploaded
files).</p>
</td></tr></tbody></table>

<p>All of these methods also support ! methods (e.g. <code>pos_int!</code>),
and all of them can be used in the <code>array</code> and
<code>array!</code> methods to support arrays of values.</p>

<p>Since parameter hashes can be nested, the <code>[]</code> method can be
used to access nested hashes:</p>

<pre class="ruby"><span class="ruby-comment"># params: {&#39;key&#39;=&gt;{&#39;sub_key&#39;=&gt;&#39;1&#39;}}</span>&#x000A;<span class="ruby-identifier">typecast_params</span>[<span class="ruby-string">&#39;key&#39;</span>].<span class="ruby-identifier">pos_int!</span>(<span class="ruby-string">&#39;sub_key&#39;</span>) <span class="ruby-comment"># =&gt; 1</span></pre>

<p>This works to an arbitrary depth:</p>

<pre class="ruby"><span class="ruby-comment"># params: {&#39;key&#39;=&gt;{&#39;sub_key&#39;=&gt;{&#39;sub_sub_key&#39;=&gt;&#39;1&#39;}}}</span>&#x000A;<span class="ruby-identifier">typecast_params</span>[<span class="ruby-string">&#39;key&#39;</span>][<span class="ruby-string">&#39;sub_key&#39;</span>].<span class="ruby-identifier">pos_int!</span>(<span class="ruby-string">&#39;sub_sub_key&#39;</span>) <span class="ruby-comment"># =&gt; 1</span></pre>

<p>And also works with arrays at any depth, if those arrays contain hashes:</p>

<pre class="ruby"><span class="ruby-comment"># params: {&#39;key&#39;=&gt;[{&#39;sub_key&#39;=&gt;{&#39;sub_sub_key&#39;=&gt;&#39;1&#39;}}]}</span>&#x000A;<span class="ruby-identifier">typecast_params</span>[<span class="ruby-string">&#39;key&#39;</span>][<span class="ruby-value">0</span>][<span class="ruby-string">&#39;sub_key&#39;</span>].<span class="ruby-identifier">pos_int!</span>(<span class="ruby-string">&#39;sub_sub_key&#39;</span>) <span class="ruby-comment"># =&gt; 1</span>&#x000A;&#x000A;<span class="ruby-comment"># params: {&#39;key&#39;=&gt;[{&#39;sub_key&#39;=&gt;[&#39;1&#39;]}]}</span>&#x000A;<span class="ruby-identifier">typecast_params</span>[<span class="ruby-string">&#39;key&#39;</span>][<span class="ruby-value">0</span>].<span class="ruby-identifier">array!</span>(<span class="ruby-value">:pos_int</span>, <span class="ruby-string">&#39;sub_key&#39;</span>) <span class="ruby-comment"># =&gt; [1]</span></pre>

<p>To allow easier access to nested data, there is a <code>dig</code> method:</p>

<pre class="ruby"><span class="ruby-identifier">typecast_params</span>.<span class="ruby-identifier">dig</span>(<span class="ruby-value">:pos_int</span>, <span class="ruby-string">&#39;key&#39;</span>, <span class="ruby-string">&#39;sub_key&#39;</span>)&#x000A;<span class="ruby-identifier">typecast_params</span>.<span class="ruby-identifier">dig</span>(<span class="ruby-value">:pos_int</span>, <span class="ruby-string">&#39;key&#39;</span>, <span class="ruby-value">0</span>, <span class="ruby-string">&#39;sub_key&#39;</span>, <span class="ruby-string">&#39;sub_sub_key&#39;</span>)</pre>

<p><code>dig</code> will return <code>nil</code> if any access while looking
up the nested value returns <code>nil</code>. There is also a
<code>dig!</code> method, which will raise an <a
href="TypecastParams/Error.html">Error</a> if <code>dig</code> would return
<code>nil</code>:</p>

<pre class="ruby"><span class="ruby-identifier">typecast_params</span>.<span class="ruby-identifier">dig!</span>(<span class="ruby-value">:pos_int</span>, <span class="ruby-string">&#39;key&#39;</span>, <span class="ruby-string">&#39;sub_key&#39;</span>)&#x000A;<span class="ruby-identifier">typecast_params</span>.<span class="ruby-identifier">dig!</span>(<span class="ruby-value">:pos_int</span>, <span class="ruby-string">&#39;key&#39;</span>, <span class="ruby-value">0</span>, <span class="ruby-string">&#39;sub_key&#39;</span>, <span class="ruby-string">&#39;sub_sub_key&#39;</span>)</pre>

<p>Note that none of these conversion methods modify
<code>request.params</code>.  They purely do the conversion and return the
converted value.  However, in some cases it is useful to do all the
conversion up front, and then pass a hash of converted parameters to an
internal method that expects to receive values in specific types.  The
<code>convert!</code> method does this, and there is also a
<code>convert_each!</code> method designed for converting multiple values
using the same block:</p>

<pre class="ruby"><span class="ruby-identifier">converted_params</span> = <span class="ruby-identifier">typecast_params</span>.<span class="ruby-identifier">convert!</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">tp</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-identifier">tp</span>.<span class="ruby-identifier">int</span>(<span class="ruby-string">&#39;page&#39;</span>)&#x000A;  <span class="ruby-identifier">tp</span>.<span class="ruby-identifier">pos_int!</span>(<span class="ruby-string">&#39;artist_id&#39;</span>)&#x000A;  <span class="ruby-identifier">tp</span>.<span class="ruby-identifier">array!</span>(<span class="ruby-value">:pos_int</span>, <span class="ruby-string">&#39;album_ids&#39;</span>)&#x000A;  <span class="ruby-identifier">tp</span>.<span class="ruby-identifier">convert!</span>(<span class="ruby-string">&#39;sales&#39;</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">stp</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-identifier">tp</span>.<span class="ruby-identifier">pos_int!</span>([<span class="ruby-string">&#39;num_sold&#39;</span>, <span class="ruby-string">&#39;num_shipped&#39;</span>])&#x000A;  <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-identifier">tp</span>.<span class="ruby-identifier">convert!</span>(<span class="ruby-string">&#39;members&#39;</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">mtp</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-identifier">mtp</span>.<span class="ruby-identifier">convert_each!</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">stp</span><span class="ruby-operator">|</span>&#x000A;      <span class="ruby-identifier">stp</span>.<span class="ruby-identifier">str!</span>([<span class="ruby-string">&#39;first_name&#39;</span>, <span class="ruby-string">&#39;last_name&#39;</span>])&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-comment"># converted_params:</span>&#x000A;<span class="ruby-comment"># {</span>&#x000A;<span class="ruby-comment">#   &#39;page&#39; =&gt; 1,</span>&#x000A;<span class="ruby-comment">#   &#39;artist_id&#39; =&gt; 2,</span>&#x000A;<span class="ruby-comment">#   &#39;album_ids&#39; =&gt; [3, 4],</span>&#x000A;<span class="ruby-comment">#   &#39;sales&#39; =&gt; {</span>&#x000A;<span class="ruby-comment">#     &#39;num_sold&#39; =&gt; 5,</span>&#x000A;<span class="ruby-comment">#     &#39;num_shipped&#39; =&gt; 6</span>&#x000A;<span class="ruby-comment">#   },</span>&#x000A;<span class="ruby-comment">#   &#39;members&#39; =&gt; [</span>&#x000A;<span class="ruby-comment">#      {&#39;first_name&#39; =&gt; &#39;Foo&#39;, &#39;last_name&#39; =&gt; &#39;Bar&#39;},</span>&#x000A;<span class="ruby-comment">#      {&#39;first_name&#39; =&gt; &#39;Baz&#39;, &#39;last_name&#39; =&gt; &#39;Quux&#39;}</span>&#x000A;<span class="ruby-comment">#   ]</span>&#x000A;<span class="ruby-comment"># }</span></pre>

<p><code>convert!</code> and <code>convert_each!</code> only return values you
explicitly specify for conversion inside the passed block.</p>

<p>You can specify the <code>:symbolize</code> option to <code>convert!</code>
or <code>convert_each!</code>, which will symbolize the resulting hash
keys:</p>

<pre class="ruby"><span class="ruby-identifier">converted_params</span> = <span class="ruby-identifier">typecast_params</span>.<span class="ruby-identifier">convert!</span>(<span class="ruby-value">symbolize:</span> <span class="ruby-keyword">true</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">tp</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-identifier">tp</span>.<span class="ruby-identifier">int</span>(<span class="ruby-string">&#39;page&#39;</span>)&#x000A;  <span class="ruby-identifier">tp</span>.<span class="ruby-identifier">pos_int!</span>(<span class="ruby-string">&#39;artist_id&#39;</span>)&#x000A;  <span class="ruby-identifier">tp</span>.<span class="ruby-identifier">array!</span>(<span class="ruby-value">:pos_int</span>, <span class="ruby-string">&#39;album_ids&#39;</span>)&#x000A;  <span class="ruby-identifier">tp</span>.<span class="ruby-identifier">convert!</span>(<span class="ruby-string">&#39;sales&#39;</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">stp</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-identifier">tp</span>.<span class="ruby-identifier">pos_int!</span>([<span class="ruby-string">&#39;num_sold&#39;</span>, <span class="ruby-string">&#39;num_shipped&#39;</span>])&#x000A;  <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-identifier">tp</span>.<span class="ruby-identifier">convert!</span>(<span class="ruby-string">&#39;members&#39;</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">mtp</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-identifier">mtp</span>.<span class="ruby-identifier">convert_each!</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">stp</span><span class="ruby-operator">|</span>&#x000A;      <span class="ruby-identifier">stp</span>.<span class="ruby-identifier">str!</span>([<span class="ruby-string">&#39;first_name&#39;</span>, <span class="ruby-string">&#39;last_name&#39;</span>])&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-comment"># converted_params:</span>&#x000A;<span class="ruby-comment"># {</span>&#x000A;<span class="ruby-comment">#   :page =&gt; 1,</span>&#x000A;<span class="ruby-comment">#   :artist_id =&gt; 2,</span>&#x000A;<span class="ruby-comment">#   :album_ids =&gt; [3, 4],</span>&#x000A;<span class="ruby-comment">#   :sales =&gt; {</span>&#x000A;<span class="ruby-comment">#     :num_sold =&gt; 5,</span>&#x000A;<span class="ruby-comment">#     :num_shipped =&gt; 6</span>&#x000A;<span class="ruby-comment">#   },</span>&#x000A;<span class="ruby-comment">#   :members =&gt; [</span>&#x000A;<span class="ruby-comment">#      {:first_name =&gt; &#39;Foo&#39;, :last_name =&gt; &#39;Bar&#39;},</span>&#x000A;<span class="ruby-comment">#      {:first_name =&gt; &#39;Baz&#39;, :last_name =&gt; &#39;Quux&#39;}</span>&#x000A;<span class="ruby-comment">#   ]</span>&#x000A;<span class="ruby-comment"># }</span></pre>

<p>Using the <code>:symbolize</code> option makes it simpler to transition
from untrusted external data (string keys), to trusted data that can be
used internally (trusted in the sense that the expected types are used).</p>

<p>Note that if there are multiple conversion <a
href="TypecastParams/Error.html">Error</a> raised inside a
<code>convert!</code> or <code>convert_each!</code>  block, they are
recorded and a single <a
href="TypecastParams/Error.html">TypecastParams::Error</a> instance is
raised after processing the block.  TypecastParams::Error#params_names can
be called on the exception to get an array of all parameter names with
conversion issues, and <a
href="TypecastParams/Error.html#method-i-all_errors">Roda::RodaPlugins::TypecastParams::Error#all_errors</a>
can be used to get an array of all <a
href="TypecastParams/Error.html">Error</a> instances.</p>

<p>Because of how <code>convert!</code> and <code>convert_each!</code> work,
you should avoid calling <a
href="TypecastParams/Params.html#method-i-5B-5D">Roda::RodaPlugins::TypecastParams::Params#[]</a>
inside the block you pass to these methods, because if the [] call fails,
it will skip the reminder of the block.</p>

<p>Be aware that when you use <code>convert!</code> and
<code>convert_each!</code>, the conversion methods called inside the block
may return nil if there is a error raised, and nested calls to
<code>convert!</code> and <code>convert_each!</code> may not return values.</p>

<p>When loading the typecast_params plugin, a subclass of
<code>TypecastParams::Params</code> is created specific to the <a
href="../../Roda.html">Roda</a> application.  You can add support for
custom types by passing a block when loading the typecast_params plugin. 
This block is executed in the context of the subclass, and calling
<code>handle_type</code> in the block can be used to add conversion
methods. <code>handle_type</code> accepts a type name and the block used to
convert the type:</p>

<pre class="ruby"><span class="ruby-identifier">plugin</span> <span class="ruby-value">:typecast_params</span> <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">handle_type</span>(<span class="ruby-value">:album</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">value</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-keyword">if</span> <span class="ruby-identifier">id</span> = <span class="ruby-identifier">convert_pos_int</span>(<span class="ruby-identifier">val</span>)&#x000A;      <span class="ruby-constant">Album</span>[<span class="ruby-identifier">id</span>]&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>

<p>By default, the typecast_params conversion procs are passed the parameter
value directly from <code>request.params</code> without modification.  In
some cases, it may be beneficial to strip leading and trailing whitespace
from parameter string values before processing, which you can do by passing
the <code>strip: :all</code> option when loading the plugin.</p>

<p>By design, typecast_params only deals with string keys, it is not possible
to use symbol keys as arguments to the conversion methods and have them
converted.</p>
</div>
<div id='method-list'>
<h2>Methods</h2>
<h3>Public Class</h3>
<ol>
<li><a href="#method-c-configure">configure</a></li>
</ol>
</div>
<div id='context'>
</div>
<div id='class-list'>
<h2>Classes and Modules</h2>
<ol>
<li><a href="TypecastParams/ClassMethods.html">Roda::RodaPlugins::TypecastParams::ClassMethods</a></li>
<li><a href="TypecastParams/InstanceMethods.html">Roda::RodaPlugins::TypecastParams::InstanceMethods</a></li>
<li><a href="TypecastParams/StringStripper.html">Roda::RodaPlugins::TypecastParams::StringStripper</a></li>
<li><a href="TypecastParams/Error.html">Roda::RodaPlugins::TypecastParams::Error</a></li>
<li><a href="TypecastParams/Params.html">Roda::RodaPlugins::TypecastParams::Params</a></li>
<li><a href="TypecastParams/ProgrammerError.html">Roda::RodaPlugins::TypecastParams::ProgrammerError</a></li>
</ol>
</div>
<div id='section'>
<div id='constants-list'>
<h2>Constants</h2>
<div class='name-list'>
<table summary='Constants'>
<tr class='top-aligned-row context-row'>
<td class='context-item-name'>CHECK_NIL</td>
<td>=</td>
<td class='context-item-value'>Object.new.freeze</td>
<td>&nbsp;</td>
<td class='context-item-desc'>
<p>Sentinal value for whether to raise exception during process</p>
</td>
</tr>
</table>
</div>
</div>
<div id='methods'>
<h2>Public Class methods</h2>
<div class='method public-class' id='method-method-c-configure'>
<a name='method-c-configure'></a>
<div class='synopsis'>
<span class='name'>configure</span>
<span class='arguments'>(app, opts=OPTS, &block)</span>

</div>
<div class='description'>

<p>Set application-specific <a href="TypecastParams/Params.html">Params</a>
subclass unless one has been set, and if a block is passed, eval it in the
context of the subclass. Respect the <code>strip: :all</code> to strip all
parameter strings before processing them.</p>

</div>
<div class='source'>
<a class='source-toggle' href='#' onclick='toggleCode(&#39;method-c-configure-source&#39;); return false'>
[show source]
</a>
<pre id='method-c-configure-source'><span class="ruby-comment"># File lib/roda/plugins/typecast_params.rb, line 934</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier ruby-title">configure</span>(<span class="ruby-identifier">app</span>, <span class="ruby-identifier">opts</span>=<span class="ruby-constant">OPTS</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)&#x000A;  <span class="ruby-identifier">app</span>.<span class="ruby-identifier">const_set</span>(<span class="ruby-value">:TypecastParams</span>, <span class="ruby-constant">Class</span>.<span class="ruby-identifier">new</span>(<span class="ruby-constant">RodaPlugins</span><span class="ruby-operator">::</span><span class="ruby-constant">TypecastParams</span><span class="ruby-operator">::</span><span class="ruby-constant">Params</span>)) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">app</span>.<span class="ruby-identifier">const_defined?</span>(<span class="ruby-value">:TypecastParams</span>)&#x000A;  <span class="ruby-identifier">app</span><span class="ruby-operator">::</span><span class="ruby-constant">TypecastParams</span>.<span class="ruby-identifier">class_eval</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">block</span>&#x000A;  <span class="ruby-keyword">if</span> <span class="ruby-identifier">opts</span>[<span class="ruby-value">:strip</span>] <span class="ruby-operator">==</span> <span class="ruby-value">:all</span>&#x000A;    <span class="ruby-identifier">app</span><span class="ruby-operator">::</span><span class="ruby-constant">TypecastParams</span>.<span class="ruby-identifier">send</span>(<span class="ruby-value">:include</span>, <span class="ruby-constant">StringStripper</span>)&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
</div>
</div>
</div>
</div>

</div>
</div>

<div id='footer-push'></div>
</div>
<div id='footer'>
<a href="https://github.com/rdoc/hanna-nouveau"><strong>Hanna Nouveau</strong> RDoc template</a>
</div>
</body>
</html>
